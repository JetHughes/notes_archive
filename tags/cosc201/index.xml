<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cosc201 on</title><link>https://jethughes.github.io/notes/tags/cosc201/</link><description>Recent content in cosc201 on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://jethughes.github.io/notes/tags/cosc201/index.xml" rel="self" type="application/rss+xml"/><item><title>07-mergesort-1</title><link>https://jethughes.github.io/notes/notes/07-mergesort-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/07-mergesort-1/</guid><description>mergesort
quicksort
divide-and-conquer</description></item><item><title>08-mergesort-2</title><link>https://jethughes.github.io/notes/notes/08-mergesort-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/08-mergesort-2/</guid><description>mergesort</description></item><item><title>09-stacks-queues-heaps</title><link>https://jethughes.github.io/notes/notes/09-stacks-queues-heaps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/09-stacks-queues-heaps/</guid><description> dynamic-linear-datatype Stack Queue priority-queue heap</description></item><item><title>10-heaps-and-heapsort</title><link>https://jethughes.github.io/notes/notes/10-heaps-and-heapsort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/10-heaps-and-heapsort/</guid><description>heapsort
1 Overview [[notes/heap]]
2 Operations 2.1 Add element Assumptions
access first vacant position set (or find) the value $H.</description></item><item><title>11-sets-maps-trees</title><link>https://jethughes.github.io/notes/notes/11-sets-maps-trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/11-sets-maps-trees/</guid><description>A set is :: a collection of elements with no repetition allowed A hash-map is :: a set of key value pairs A tree is :: a general concept of a way of organising data.</description></item><item><title>12-binary-search-tree-operations</title><link>https://jethughes.github.io/notes/notes/12-binary-search-tree-operations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/12-binary-search-tree-operations/</guid><description>Recall binary-search-tree
binary search tree operations</description></item><item><title>13-bst-traversals-and-balance</title><link>https://jethughes.github.io/notes/notes/13-bst-traversals-and-balance/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/13-bst-traversals-and-balance/</guid><description>tree-traversal balancing-binary-search-trees</description></item><item><title>14-balancing-bsts</title><link>https://jethughes.github.io/notes/notes/14-balancing-bsts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/14-balancing-bsts/</guid><description> balancing-binary-search-trees
avl-tree red-black-tree treap</description></item><item><title>16-c201-archive</title><link>https://jethughes.github.io/notes/notes/16-c201-archive/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/16-c201-archive/</guid><description>In a perfect world keys from a class k, valuyes from a class v there are only 4000 possible keys each key, k, has a unique four digit identifier than we can obtain in constant time as k.</description></item><item><title>16-hasing-maps-sets</title><link>https://jethughes.github.io/notes/notes/16-hasing-maps-sets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/16-hasing-maps-sets/</guid><description>Hash functions Collisions Chaining open addressing basic implementation</description></item><item><title>17-collision-resolution-probing</title><link>https://jethughes.github.io/notes/notes/17-collision-resolution-probing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/17-collision-resolution-probing/</guid><description>linear-probing</description></item><item><title>17-dynamic-programming</title><link>https://jethughes.github.io/notes/notes/15-dynamic-programming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/15-dynamic-programming/</guid><description/></item><item><title>19-graphs</title><link>https://jethughes.github.io/notes/notes/19-graphs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/19-graphs/</guid><description>graphs</description></item><item><title>20-graphs-2</title><link>https://jethughes.github.io/notes/notes/20-graphs-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/20-graphs-2/</guid><description>Graph drawing is its own problem.
One easy way is to draw the vertices is clockwise order and draw edges between them</description></item><item><title>analysis-of-recursive-algorithms</title><link>https://jethughes.github.io/notes/notes/analysis-of-recursive-algorithms/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/analysis-of-recursive-algorithms/</guid><description>induction and recursion are linked inductive approach is esential for understanding time-complexity of resursive algorithms 1 Proof by induction induction Find a (positive integer) parameter that gets smaller in all recursive calls Prove inductively that &amp;ldquo;for all values of the parameter, the result computed is correct&amp;rdquo; To do that:</description></item><item><title>Assignment 02</title><link>https://jethughes.github.io/notes/notes/assignment-02/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/assignment-02/</guid><description>1 Introduction 1.1 Setup This report will discuss various strategies for managing a warehouse . A warehouse will be simulated as follows:</description></item><item><title>asymptotic-notation</title><link>https://jethughes.github.io/notes/notes/aymptotic-notation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/aymptotic-notation/</guid><description>Asymptotic notations are used in computer science to classify algorithms based how its space and time requirements grow as the input grows.</description></item><item><title>avl-tree</title><link>https://jethughes.github.io/notes/notes/avl-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/avl-tree/</guid><description>AVL tree most basic and obvious.
each node contains some extra information: the difference between the height of its right and left subtee.</description></item><item><title>balancing-binary-search-trees</title><link>https://jethughes.github.io/notes/notes/balancing-binary-search-trees/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/balancing-binary-search-trees/</guid><description>the height of a BST is the length of its longest chain. Most operations are $O(n)$ where n is the height of the tree.</description></item><item><title>binary-search-tree</title><link>https://jethughes.github.io/notes/notes/binary-search-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/binary-search-tree/</guid><description>code
bst-operations
a collection of nodes with one distinguished node called the root
rules:
the node data contains a key which comes from some ordered type e.</description></item><item><title>bst-operations</title><link>https://jethughes.github.io/notes/notes/bst-operations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/bst-operations/</guid><description>Search operation We want to search in a BST for a key k returning true if it is found and false if it is not</description></item><item><title>cosc-201</title><link>https://jethughes.github.io/notes/notes/cosc-201/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/cosc-201/</guid><description>Assignments [[notes/assignment-02]] Analysis aymptotic-notation induction analysis-of-recursive-algorithms Paradigms divide-and-conquer unite-and-conquer dynamic-programming memoization Data Structues union-find priority-queue dynamic-linear-datatype Stack Queue heap treap hash-map linear-probing set tree binary-search-tree balancing-binary-search-trees red-black-tree avl-tree bst-operations tree-traversal graphs Algorithms mergesort heapsort [ quicksort] Lectures 07-mergesort-1 08-mergesort-2 09-stacks-queues-heaps 10-heaps-and-heapsort 11-sets-maps-trees 12-binary-search-tree-operations 13-bst-traversals-and-balance 14-balancing-bsts 15-dynamic-programming 16-hasing-maps-sets 17-collision-resolution-probing 18-hash-examples 19-graphs 20-graphs-2 Archive 16-c201-archive</description></item><item><title>divide-and-conquer</title><link>https://jethughes.github.io/notes/notes/divide-and-conquer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/divide-and-conquer/</guid><description>Divide an conquer algorithms have three parts:
pre ⇒ break apartinto two or more smaller problems whose size add up to at most n Rec ⇒ solve those problems recursively post ⇒ combine solutions into a solution of the original problem</description></item><item><title>dynamic-linear-datatype</title><link>https://jethughes.github.io/notes/notes/dynamic-linear-datatype/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/dynamic-linear-datatype/</guid><description>Both are Dynamic linear data types (interface)
An abstraction of a collection of data organised &amp;ldquo;in a line&amp;rdquo; which supprts addition of new elements and the removal of (some) old elements</description></item><item><title>dynamic-programming</title><link>https://jethughes.github.io/notes/notes/dynamic-programming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/dynamic-programming/</guid><description>A method of designing algorithms, where a higher amount of space is used, in order to gain reduction in time. This usually done by remembering previous calculations.</description></item><item><title>graphs</title><link>https://jethughes.github.io/notes/notes/graphs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/graphs/</guid><description>Represents a set of things with relationships between them.
a set of vertices some edges between them edges on some graphs have weights edges on some graphs are directed Some graphs are named e.</description></item><item><title>heap</title><link>https://jethughes.github.io/notes/notes/heap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/heap/</guid><description>A tree where:
every elements should be greater than ites children the structure should be filled from top to bottom and left to right To remove an element</description></item><item><title>heaps-and-heapsort</title><link>https://jethughes.github.io/notes/notes/heapsort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/heapsort/</guid><description>3 Heap Sort In place and ϴ(n lg n)
start with array using itself as a heap, add the elements one at a time until all been added Then remove them one at a time - the largest elements gets removed first and the place where is needs to be put gets freed from the map 4 Heap sort vs Merge sort heap &amp;ndash;&amp;gt; in place, ϴ(n lg n) merge &amp;ndash;&amp;gt; not in place, Ο(n lg n)</description></item><item><title>induction</title><link>https://jethughes.github.io/notes/notes/induction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/induction/</guid><description>Induction 1 PECS Phases of argument by induction
Preparation -&amp;gt; most important Execution -&amp;gt; becomes routine if prep is good Checking -&amp;gt; second most important Satisfaction 1.</description></item><item><title>linear-probing</title><link>https://jethughes.github.io/notes/notes/linear-probing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/linear-probing/</guid><description>animation demo
A method of collision resolution for hash-maps. In this scheme, each cell of the map contains a single key-value pair.</description></item><item><title>memoization</title><link>https://jethughes.github.io/notes/notes/memoization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/memoization/</guid><description>A method of designing algorithms which is similar to dynamic programming in that previously calculated answers are stored in memory</description></item><item><title>mergesort</title><link>https://jethughes.github.io/notes/notes/mergesort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/mergesort/</guid><description>Mergesort is a divide-and-conquer algorithm. It works by recursively splitting the array in half then merging the two (sorted) halfs together .</description></item><item><title>priority-queue</title><link>https://jethughes.github.io/notes/notes/priority-queue/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/priority-queue/</guid><description>A dynamic linear data type that supports addition and removal on entrie each entry hase a value and a priority (key) removal returns the item with the greatest priority Implementation stores items and priorities in an array.</description></item><item><title>quicksort</title><link>https://jethughes.github.io/notes/notes/quicksort/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/quicksort/</guid><description>pre ⇒ select pivot and split the array
rec ⇒ apply quicksort to the partitions
post ⇒ not much
designeds when sorting inplace was important</description></item><item><title>red-black-tree</title><link>https://jethughes.github.io/notes/notes/red-black-tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/red-black-tree/</guid><description>Red Black trees most used current one. Used in java treemap
each node is either red or black
the rules are:</description></item><item><title>set</title><link>https://jethughes.github.io/notes/notes/set/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/set/</guid><description>links: java docs for set interface
A collection of items with no repetition allowed
How do we want to be able to use them?</description></item><item><title>treap</title><link>https://jethughes.github.io/notes/notes/treap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/treap/</guid><description>Treaps Link betwen heaps and trees that uses randomisation
I we are added items to a bst in random order then an unbalanced situation would be possible but highly unlikely.</description></item><item><title>tree</title><link>https://jethughes.github.io/notes/notes/tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/tree/</guid><description>not so much a data type. More of a data concept of a way in which data can be organised</description></item><item><title>tree-traversal</title><link>https://jethughes.github.io/notes/notes/tree-traversal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/tree-traversal/</guid><description>Visit each node in the tree once. So we need to visit n, all the nodes in L, and all the nodes in R.</description></item><item><title>union-find</title><link>https://jethughes.github.io/notes/notes/union-find/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/union-find/</guid><description>1 Example We have 12 &amp;lsquo;objects&amp;rsquo; Some pairs have been connected Nodes with a sequence of edges between them form a group e.</description></item><item><title>unite-and-conquer</title><link>https://jethughes.github.io/notes/notes/unite-and-conquer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/unite-and-conquer/</guid><description>5 | 8 | 2 | 3 | 4 | 1 | 7 | 6
5 8 | 2 3 | 1 4 | 6 7</description></item></channel></rss>