<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cosc204 on</title><link>https://jethughes.github.io/notes/tags/cosc204/</link><description>Recent content in cosc204 on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://jethughes.github.io/notes/tags/cosc204/index.xml" rel="self" type="application/rss+xml"/><item><title>01-bits-and-bytes</title><link>https://jethughes.github.io/notes/notes/01-bits-and-bytes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/01-bits-and-bytes/</guid><description>memory unicode ASCII digital-data
What is data A fact — a piece of information corresponds to discreete facts about phenomena from which we gain information abou the world The concept of a value is fundamental to data e.</description></item><item><title>02-combinatorial-logic</title><link>https://jethughes.github.io/notes/notes/02-combinatorial-logic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/02-combinatorial-logic/</guid><description>slides
transistors
combinatorial-logic-circuit
boolean-equations
logic-gates</description></item><item><title>03-sequential-logic-circuits</title><link>https://jethughes.github.io/notes/notes/03-sequential-logic-circuits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/03-sequential-logic-circuits/</guid><description>comb log. circuits always produce the same output with the same inputs
Sequential logic circuit output depends not only on the inputs but also past history (memory)</description></item><item><title>04-computer-architecture</title><link>https://jethughes.github.io/notes/notes/04-computer-architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/04-computer-architecture/</guid><description>memory
control-unit
bus
CPU
ALU</description></item><item><title>05-6809-assembly</title><link>https://jethughes.github.io/notes/notes/05-6809-assembly/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/05-6809-assembly/</guid><description>6809 Warnings different CPU architectures have their own machine codes and their own assembly languages assembly language programs are not portable across CPU architectures (e.</description></item><item><title>06-6809-programming</title><link>https://jethughes.github.io/notes/notes/06-6809-programming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/06-6809-programming/</guid><description>difficult
no variables GOTO not loops only compare ints and bytes not really routines all vars global case sensitive Hello World need a routine that given a string will print each chracter one at a time need to know how to print Routines 1 2 routine: rts no params no local vars calling routine</description></item><item><title>07-6809-advanced</title><link>https://jethughes.github.io/notes/notes/07-6809-advanced/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/07-6809-advanced/</guid><description>addressing modes implied inca immediate lda #$00 extended LDA $31FE extended indirect LDA [$31FE] or LDA [HERE] points to a memory location which specifies another memory location direct LDA $ff or lda &amp;lt;HERE register trf X,Y indexed LDA $311E, X use memory location that is the sum of the operands LDA ,X LDA $23,X etc indexed indirect LDA [$10, X] relative BEQ HERE BEQ does a short branch LBEQ does a long branch the value is relative to HERE program counter relative LDA TABLE,PCR ; A = the value stored at TABLE if all memory references are relative, then the program cna be loaded anywhere is memory, and will still work.</description></item><item><title>08-intro-to-c</title><link>https://jethughes.github.io/notes/notes/08-intro-to-c/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/08-intro-to-c/</guid><description>Developed 1972 for Unix
widely used compilers esxist for most OSs and architectiures diverse use OSs, device drivers, protocol stacks less so for application software low level language features map to CPU features not Object Oriented no classes etc “C is an imperative procedural language supporting structured programming, lexical variable scope, and recursion, with a static type system.</description></item><item><title>09-intro-to-c-2</title><link>https://jethughes.github.io/notes/notes/09-intro-to-c-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/09-intro-to-c-2/</guid><description>Variables and Pointers 1 2 3 va memory[3] *va memory[memory[3]] **va memory[memory[memory[3]]] * is known as dereferncing ** is known as double-dereferncing</description></item><item><title>10-intro-to-c-arrays-malloc-free</title><link>https://jethughes.github.io/notes/notes/10-intro-to-c-arrays-malloc-free/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/10-intro-to-c-arrays-malloc-free/</guid><description>Arrays must declare with size 1 2 3 4 uint32_t array[10]; float matrix[5][6]; double balance[5] = {1000.0, 2.</description></item><item><title>11-struct-and-union</title><link>https://jethughes.github.io/notes/notes/11-struct-and-union/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/11-struct-and-union/</guid><description>Struct not a calss
class like composite data type called struct POD plain old data declare 1 2 3 4 5 6 7 8 9 struct &amp;lt;name&amp;gt;{ &amp;lt;type&amp;gt;&amp;lt;name&amp;gt;; &amp;lt;type&amp;gt;&amp;lt;name&amp;gt;; } &amp;lt;variable&amp;gt;; struct point_2d { double x; double y; } point; typically an anonymous struct is declared and then given a name with typedef</description></item><item><title>12-pointers-to-routines</title><link>https://jethughes.github.io/notes/notes/12-pointers-to-routines/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/12-pointers-to-routines/</guid><description>compiler ⇒ converts high level language description of program into assembly description of the program assembler ⇒ converts assebly language description into machine code description loader ⇒ loads program into memory, loaded at $4000</description></item><item><title>13-OS-intro</title><link>https://jethughes.github.io/notes/notes/13-OS-intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/13-OS-intro/</guid><description>why learn OS security optimisation wierd bugs &amp;ldquo;crown of programming&amp;rdquo; understand hardware better embedded sys and IoT co-design of hardware and software what is an OS a program (also called OS kernel) loaded onto RAM first when pc is turned on OS kernel (in kernel space) has highest privilege and can access any hardware directly user programs (in user space) cannot acces hardware unless permitted otherwise by the OS kernel via service request (sys call) a program (OS kernel) that manages the different aspects of the opereration of the machine and runs with the highest privilege in a protected domain</description></item><item><title>14-processes-and-system-calls</title><link>https://jethughes.github.io/notes/notes/14-processes-and-system-calls/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/14-processes-and-system-calls/</guid><description>heirarchical structure in software systems system calls and interrupts representing process in OSs overview of process scheduling Heirarchical structure software systems have modularity</description></item><item><title>15-file-systems</title><link>https://jethughes.github.io/notes/notes/15-file-systems/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/15-file-systems/</guid><description>what is a file (LINUX) an interface of OS to users
os manages files just as files - it doesn&amp;rsquo;t care what type of file it is - they are all bytes arranges logically in sequence.</description></item><item><title>16-device-drivers</title><link>https://jethughes.github.io/notes/notes/16-device-drivers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/16-device-drivers/</guid><description>Device controller and driver driver Defn: a special kernel module that contrls the operations of a device with the device specific information controller Defn: a hardware unit on a device that can know and control a devices status or behaviour, which communicates with the CPU via a driver</description></item><item><title>17-processes-communication</title><link>https://jethughes.github.io/notes/notes/17-processes-communication/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/17-processes-communication/</guid><description>cooperating processes defn: coop process - execution of one process can affect the execution of another. e.e.g, processes for aprallel computing, threads for multithreading.</description></item><item><title>18-processes-sharing-and-threads</title><link>https://jethughes.github.io/notes/notes/18-processes-sharing-and-threads/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/18-processes-sharing-and-threads/</guid><description>Shared memory for processes Can&amp;rsquo;t assume all variables are initally zero. OS decide which process maps who which physical address</description></item><item><title>19-cpu-scheduling</title><link>https://jethughes.github.io/notes/notes/19-cpu-scheduling/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/19-cpu-scheduling/</guid><description>why shedule?
keep cpu busy (cpu utilisation) so processed dont hae to spend time waithing for the CPU even if cpu is always bust executing processses in different orders can change the average time spent in queue cpu burst (diagram is old the timing will have changed) between burst - waiting for io so that interactive processes respond quickly time spent waiting in total average time between visits to CPU criteria</description></item><item><title>20-sync-deadlock</title><link>https://jethughes.github.io/notes/notes/20-sync-deadlock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/20-sync-deadlock/</guid><description>Bounded buffer problem producer consumer problem
issues
no data in buffe: consumer has nothing to consume: data race buffer is full: no space for producer to produce: busy waiting private vars</description></item><item><title>21-memory-management</title><link>https://jethughes.github.io/notes/notes/21-memory-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/21-memory-management/</guid><description>storage heirachy primary storage - cache and main memory secondaryy - hard drive
as we move from secondary to primary:</description></item><item><title>22-virtual-memory</title><link>https://jethughes.github.io/notes/notes/22-virtual-memory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/22-virtual-memory/</guid><description>Swapping and virtual memory Demand paging page replacement algorithms frame allocation thrashing</description></item><item><title>6809</title><link>https://jethughes.github.io/notes/notes/6809/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/6809/</guid><description>cheatsheet lessons Routines All variables are global so there is no params or local vars.
There are three way to &amp;ldquo;Branch&amp;rdquo; to a subroutine.</description></item><item><title>6809-addressing-modes</title><link>https://jethughes.github.io/notes/notes/6809-addressing-modes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/6809-addressing-modes/</guid><description> name example description implied inca 0immediate lda #$00 extended lda $31FE extended indirect lda [$31FE] direct lda $FF$ or lda &amp;lt;HERE register trf X,Y indexed lda #311E, X sta 0,X indexed relative lda [$10, X] relative beq HERE pr lda TABLE,PCR</description></item><item><title>ALU</title><link>https://jethughes.github.io/notes/notes/ALU/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/ALU/</guid><description>part of the CPU
performs arithmetic add, subtract, etc. logical operations and, or, shift, etc subunits lofical operations addition multiplication and dividion shifting comparison logical tests (if, &amp;gt;0, &amp;lt;0, =0, &amp;lt;=0, etc)</description></item><item><title>ASCII</title><link>https://jethughes.github.io/notes/notes/ASCII/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/ASCII/</guid><description>ASCII Character Code The computer uses ch as a integer index into a pre-existing table the computer screen is made up of a thousand little dots called pixels.</description></item><item><title>boolean-equations</title><link>https://jethughes.github.io/notes/notes/boolean-equations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/boolean-equations/</guid><description>Often used to describe/define combinatorial-logic-circuit
Precedence Precedence
NOT is unary, so it has the highest precedence AND is mulitply, so it comes next OR is like plus, to it comes last Creating boolean equations Creating boolean equations:</description></item><item><title>bus</title><link>https://jethughes.github.io/notes/notes/bus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/bus/</guid><description>data bus
address bus
control bus
conmmunicate between parts of the computer</description></item><item><title>C-language</title><link>https://jethughes.github.io/notes/notes/C-language/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/C-language/</guid><description>“C is an imperative procedural language supporting structured programming, lexical variable scope, and recursion, with a static type system. It was designed to be compiled to provide low-level access to memory and language constructs that map efficiently to machine instructions, all with minimal runtime support.</description></item><item><title>cmoc</title><link>https://jethughes.github.io/notes/notes/cmoc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/cmoc/</guid><description>CMOC is a 6809 c compiler.
it compiles c code into 6809 assembly
callling conventions
A routine must preserve Y, U, S and DP</description></item><item><title>combinatorial-logic-circuit</title><link>https://jethughes.github.io/notes/notes/combinatorial-logic-circuit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/combinatorial-logic-circuit/</guid><description>[!Definition] Combinatorial Logic Circuit is a circuit whose digital outputs are dependent only on its digital inputs They can be described using logic expressions and therefore logic gates.</description></item><item><title>computer-architecture</title><link>https://jethughes.github.io/notes/notes/computer-architecture/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/computer-architecture/</guid><description>Stored program computer made up of:
CPU memory etc Von Neumann Architecture three key concepts data and instructions are stored in a single read-write memory contents of memory are addressable by location, without regard to the type of data contained execution occurs in a sequential fashion, unless explicitly altered, from one instuction to the next programs and data are the same thing and so its possible to write soure code (data) and comile them into executables (programs) that can be loaded as data and then executed as programs Early computers</description></item><item><title>control-unit</title><link>https://jethughes.github.io/notes/notes/control-unit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/control-unit/</guid><description>Control unit coordinates the operation of the computer generates control signals connect registers to the bus control the function of the ALU provides timing signals to the system allso associated with the decoding and executuion of instructions in a pipelined system</description></item><item><title>cosc-204</title><link>https://jethughes.github.io/notes/notes/cosc-204/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/cosc-204/</guid><description>page
Notes ASCII unicode digital-data memory boolean-equations combinatorial-logic-circuit logic-gates transistors demultiplexor sequential-circuits bus control-unit CPU ALU computer-architecture 6809-addressing-modes 6809 Lectures 01-bits-and-bytes 02-combinatorial-logic 03-sequential-logic-circuits 04-computer-architecture 05-6809-assembly 06-6809-programming 07-6809-advanced 08-intro-to-c 09-intro-to-c-2 10-intro-to-c-arrays-malloc-free 11-struct-and-union 12-pointers-to-routines 13-OS-intro 14-processes-and-system-calls 15-file-systems 16-device-drivers 17-processes-communication 18-processes-sharing-and-threads 19-cpu-scheduling 20-sync-deadlock 21-memory-management Archive Info By completion of this paper students are expected to: - Understand how programs are executed on computer hardware - Demonstrate an ability to read and write assembly language programs - Understand the fundamental principles and structure of an operating system - Be able to construct programs in C and understand its role as a systems programming language - Understand core operating systems algorithms such as process scheduling and resource allocation and management - Be aware of the importance of efficient use of resources from computational, economic, and environmental viewpoints</description></item><item><title>CPU</title><link>https://jethughes.github.io/notes/notes/CPU/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/CPU/</guid><description>The CPU controls the computer. It is the main component.
A CPU is made of many components including
Registers control-unit ALU data is transeferred betwen these components and memory through data buses</description></item><item><title>demultiplexor</title><link>https://jethughes.github.io/notes/notes/demultiplexor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/demultiplexor/</guid><description>Demultiplexor Mutli way swtich where the address determines which output recieves the input</description></item><item><title>digital-data</title><link>https://jethughes.github.io/notes/notes/digital-data/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/digital-data/</guid><description>What is data A fact — a piece of information corresponds to discreete facts about phenomena from which we gain information abou the world The concept of a value is fundamental to data e.</description></item><item><title>logic-gates</title><link>https://jethughes.github.io/notes/notes/logic-gates/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/logic-gates/</guid><description>Logic Gates NOT AND OR NAND NOR XOR/EOR</description></item><item><title>memory</title><link>https://jethughes.github.io/notes/notes/memory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/memory/</guid><description>Computer memory is a series of switches (similar to the switchboard in a house). Each switch is identified by a number and is either on or off.</description></item><item><title>sequential-circuits</title><link>https://jethughes.github.io/notes/notes/sequential-circuits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/sequential-circuits/</guid><description>combinatorial-logic-circuits always produce the same outputs given the same input. Sequential curcuits on the other hand, produce different outputs depending on past history and the inputs.</description></item><item><title>transistors</title><link>https://jethughes.github.io/notes/notes/transistors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/transistors/</guid><description>Transistors B: Base ⇒ A swtich connecting C to E open (C is disconnected from E) when supplied 0v closed (C is connected to E) by applying +5V C: Collector E: Emitter Possible to create NAND gate using just transistors ∴ possible to create all logic gates using only transistors [^3]</description></item><item><title>unicode</title><link>https://jethughes.github.io/notes/notes/unicode/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jethughes.github.io/notes/notes/unicode/</guid><description>Unicode Other non roman languages greek, arabic, chinese, hebrew, japanese, thai etc. atrology symbols emoji etc Unicode developed by the Unicode Consortium coordinated with ISO/IEC 10646 a 21-bit code with 144,697 characters from 159 scripts unicode maps from character numbers (code points) into glyphs (graphical representations) Some(many) are reserved</description></item></channel></rss>